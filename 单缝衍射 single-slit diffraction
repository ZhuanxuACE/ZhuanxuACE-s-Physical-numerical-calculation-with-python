#利用菲涅尔-惠更斯原理制作 Produced using the Fresnel-Huygens principle
import numpy as np
from matplotlib import pyplot as plt
from matplotlib.animation import FuncAnimation

x = np.linspace(-10,10,300)
y = np.linspace(-10,10,300)
Lambda = 0.8#波长
k = 2*np.pi/Lambda#波矢
x,y = np.meshgrid(x,y)
z = np.sin(k*(x**2 + y**2)**0.5)
t = 10
A = np.sin(t)
z = 0
length_gap = 4#缝宽
n = 30#产生波数
c = n/length_gap

for i in range(n):
    z = np.sin(k*(x**2 + (y-i/c)**2)**0.5 - t) + z
print(z.shape)
fig = plt.figure(figsize=(16, 9),dpi = 80)
ax = fig.add_subplot(1,1,1)
pig = ax.imshow(z,cmap = 'bwr')
fig.colorbar(pig)
#ax2 = fig.add_subplot(1,2,2)
#ax2 = ax2.plot(z[:,299]**2,np.linspace(-10,10,280))
def update(frames):    
    t = frames*np.pi/50
    z = 0
    
    #缝宽逐渐变大
    length_gap = (frames+1)/20#缝宽
    n = 30#产生波数
    c = n/length_gap
    for i in range(n):
        z = np.sin(k*((x+10)**2 + (y+length_gap/2-i/(c))**2)**0.5 - t) + z
    ax.set_title('gap_length={:.2f}  wave_length={:.2f}'.format(length_gap,Lambda),fontsize = 20)
    
    # #波长逐渐边长
    # Lambda = (100-frames+20)/40#波长
    # length_gap = 2
    # k = 2*np.pi/Lambda#波矢
    # n = 30#产生波数
    # c = n/length_gap
    # for i in range(n):
    #     z = np.sin(k*((x+10)**2 + (y+length_gap/2-i/(c))**2)**0.5 - t) + z
    # ax.set_title('gap_length=2  wave_length={:.2f}'.format(Lambda),fontsize = 20)

    #波运动
    # for i in range(n):
    #     z = np.sin(k*((x+10)**2 + (y-i/(2*c))**2)**0.5 - t) + z
        
    a = pig.set_data(z)
    return a
ani = FuncAnimation(fig,update,frames = 100,interval=40)
#ani.save("Single-hole diffraction.gif", writer="pillow")
plt.show()
